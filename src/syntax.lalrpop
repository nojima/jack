use crate::ast::{Expr, UnaryOp, BinaryOp};
use crate::lexer;
use crate::token::Token;
use std::collections::HashMap;

grammar;

//-----------------------------------------------------------------------------

CommaSeparated<T>: Vec<T> = {
    <mut v:(<T> ",")*> <e:T?> => match e {
        None => v,
        Some(e) => {
            v.push(e);
            v
        }
    }
};

//-----------------------------------------------------------------------------

pub Expr: Expr = 
    AddExpr;

AddExpr: Expr = {
    MulExpr,
    <lhs:AddExpr> <op:AddOp> <rhs:MulExpr>
        => Expr::BinaryOp(op, Box::new(lhs), Box::new(rhs)),
};

AddOp: BinaryOp = {
    "+" => BinaryOp::Add,
    "-" => BinaryOp::Sub,
};

MulExpr: Expr = {
    UnaryExpr,
    <lhs:MulExpr> <op:MulOp> <rhs:UnaryExpr>
        => Expr::BinaryOp(op, Box::new(lhs), Box::new(rhs)),
};

MulOp: BinaryOp = {
    "*" => BinaryOp::Mul,
    "/" => BinaryOp::Div,
    "%" => BinaryOp::Mod,
};

UnaryExpr: Expr = {
    Term,
    "-" <Term> => Expr::UnaryOp(UnaryOp::Neg, Box::new(<>)),
};

Term: Expr = {
    Literal,
    "(" <Expr> ")",
};

Literal: Expr = {
    "true"  => Expr::Bool(true),
    "false" => Expr::Bool(false),
    "null"  => Expr::Null,
    Number  => Expr::Number(<>),
    String  => Expr::String(<>),
    Array   => Expr::Array(<>),
    Dict    => Expr::Dict(<>),
};

Number: f64 = "number literal";

String: String = "string literal";

Identifier: String = "identifier";

Array: Vec<Expr> =
    "[" <CommaSeparated<Expr>> "]";

Dict: HashMap<String, Expr> =
    "{" <CommaSeparated<KeyValue>> "}" =>
        <>.into_iter().collect();

KeyValue: (String, Expr) =
    <k:String> ":" <v:Expr> => (k, v);
 
extern {
    type Location = usize;
    type Error = lexer::LexicalError;

    enum Token {
        "true"  => Token::True,
        "false" => Token::False,
        "null"  => Token::Null,

        "number literal" => Token::Number(<f64>),
        "string literal" => Token::String(<String>),
        "identifier"     => Token::Identifier(<String>),

        ":" => Token::Colon,
        "," => Token::Comma,
        "(" => Token::LParen,
        ")" => Token::RParen,
        "[" => Token::LBracket,
        "]" => Token::RBracket,
        "{" => Token::LBrace,
        "}" => Token::RBrace,
        "+" => Token::Plus,
        "-" => Token::Minus,
        "*" => Token::Asterisk,
        "/" => Token::Slash,
        "%" => Token::Percent,
    }
}
