use std::collections::HashMap;
use crate::token::Token;
use crate::ast::Expr;
use crate::lexer;

grammar;

//-----------------------------------------------------------------------------

CommaSeparated<T>: Vec<T> = {
    <mut v:(<T> ",")*> <e:T?> => match e {
        None => v,
        Some(e) => {
            v.push(e);
            v
        }
    }
};

//-----------------------------------------------------------------------------

pub Expr: Expr = {
    "true"  => Expr::Bool(true),
    "false" => Expr::Bool(false),
    "null"  => Expr::Null,
    Number  => Expr::Number(<>),
    String  => Expr::String(<>),
    Array   => Expr::Array(<>),
    Dict    => Expr::Dict(<>),
};

Number: f64 = "number literal";

String: String = "string literal";

Identifier: String = "identifier";

Array: Vec<Expr> =
    "[" <CommaSeparated<Expr>> "]";

Dict: HashMap<String, Expr> =
    "{" <CommaSeparated<KeyValue>> "}" =>
        <>.into_iter().collect();

KeyValue: (String, Expr) =
    <k:String> ":" <v:Expr> => (k, v);
 
extern {
    type Location = usize;
    type Error = lexer::LexicalError;

    enum Token {
        "true"  => Token::True,
        "false" => Token::False,
        "null"  => Token::Null,

        "number literal" => Token::Number(<f64>),
        "string literal" => Token::String(<String>),
        "identifier"     => Token::Identifier(<String>),

        ":" => Token::Colon,
        "," => Token::Comma,
        "[" => Token::LBracket,
        "]" => Token::RBracket,
        "{" => Token::LBrace,
        "}" => Token::RBrace,
    }
}
