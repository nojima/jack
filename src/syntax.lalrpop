use crate::ast::{Expr, UnaryOp, BinaryOp};
use crate::lexer;
use crate::token::Token;
use compact_str::CompactString;

grammar;

//-----------------------------------------------------------------------------

CommaSeparated<T>: Vec<T> = {
    <mut v:(<T> ",")*> <e:T?> => match e {
        None => v,
        Some(e) => {
            v.push(e);
            v
        }
    }
};

//-----------------------------------------------------------------------------

pub Expr: Expr =  {
    CondExpr,
    IfExpr,
    LocalExpr,
};

IfExpr: Expr =
    "if" <cond:Expr> "then" <then:Expr> "else" <else_:Expr>
        => Expr::If(Box::new(cond), Box::new(then), Box::new(else_));

LocalExpr: Expr =
    "local" <name:Identifier> "=" <expr1:Expr> ";" <expr2:Expr>
        => Expr::Local(name, Box::new(expr1), Box::new(expr2));

CondExpr: Expr = {
    AddExpr,
    <lhs:AddExpr> <op:CondOp> <rhs:AddExpr>
        => Expr::BinaryOp(op, Box::new(lhs), Box::new(rhs)),
}

CondOp: BinaryOp = {
    "==" => BinaryOp::Eq,
    "!=" => BinaryOp::NotEq,
};

AddExpr: Expr = {
    MulExpr,
    <lhs:AddExpr> <op:AddOp> <rhs:MulExpr>
        => Expr::BinaryOp(op, Box::new(lhs), Box::new(rhs)),
};

AddOp: BinaryOp = {
    "+" => BinaryOp::Add,
    "-" => BinaryOp::Sub,
};

MulExpr: Expr = {
    UnaryExpr,
    <lhs:MulExpr> <op:MulOp> <rhs:UnaryExpr>
        => Expr::BinaryOp(op, Box::new(lhs), Box::new(rhs)),
};

MulOp: BinaryOp = {
    "*" => BinaryOp::Mul,
    "/" => BinaryOp::Div,
    "%" => BinaryOp::Mod,
};

UnaryExpr: Expr = {
    Term,
    "-" <Term> => Expr::UnaryOp(UnaryOp::Neg, Box::new(<>)),
};

Term: Expr = {
    Literal,
    Variable,
    "(" <Expr> ")",
};

Variable: Expr =
    Identifier => Expr::Variable(<>);

Literal: Expr = {
    "true"  => Expr::Bool(true),
    "false" => Expr::Bool(false),
    "null"  => Expr::Null,
    Number  => Expr::Number(<>),
    String  => Expr::String(<>),
    Array   => Expr::Array(<>),
    Dict    => Expr::Dict(<>),
};

Number: f64 = "number literal";

String: String = "string literal";

Identifier: CompactString = "identifier";

Array: Vec<Expr> =
    "[" <CommaSeparated<Expr>> "]";

Dict: Vec<(CompactString, Expr)> =
    "{" <CommaSeparated<KeyValue>> "}";

KeyValue: (CompactString, Expr) =
    <k:Key> ":" <v:Expr> => (k.into(), v);

Key: CompactString = {
    String => <>.into(),
    Identifier,
};
 
extern {
    type Location = usize;
    type Error = lexer::LexicalError;

    enum Token {
        "true"  => Token::True,
        "false" => Token::False,
        "null"  => Token::Null,

        "if" => Token::If,
        "then" => Token::Then,
        "else" => Token::Else,
        "local" => Token::Local,

        "number literal" => Token::Number(<f64>),
        "string literal" => Token::String(<String>),
        "identifier"     => Token::Identifier(<CompactString>),

        ":" => Token::Colon,
        ";" => Token::Semicolon,
        "," => Token::Comma,
        "(" => Token::LParen,
        ")" => Token::RParen,
        "[" => Token::LBracket,
        "]" => Token::RBracket,
        "{" => Token::LBrace,
        "}" => Token::RBrace,
        "+" => Token::Plus,
        "-" => Token::Minus,
        "*" => Token::Asterisk,
        "/" => Token::Slash,
        "%" => Token::Percent,
        "=" => Token::Eq,
        "==" => Token::EqEq,
        "!" => Token::Exclamation,
        "!=" => Token::NotEq,
    }
}
